// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TxIn.proto

#ifndef PROTOBUF_INCLUDED_TxIn_2eproto
#define PROTOBUF_INCLUDED_TxIn_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3006001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TxIn_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_TxIn_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_TxIn_2eproto();
namespace Enze {
class OutPoint;
class OutPointDefaultTypeInternal;
extern OutPointDefaultTypeInternal _OutPoint_default_instance_;
class TxIn;
class TxInDefaultTypeInternal;
extern TxInDefaultTypeInternal _TxIn_default_instance_;
}  // namespace Enze
namespace google {
namespace protobuf {
template<> ::Enze::OutPoint* Arena::CreateMaybeMessage<::Enze::OutPoint>(Arena*);
template<> ::Enze::TxIn* Arena::CreateMaybeMessage<::Enze::TxIn>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Enze {

// ===================================================================

class OutPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Enze.OutPoint) */ {
 public:
  OutPoint();
  virtual ~OutPoint();

  OutPoint(const OutPoint& from);

  inline OutPoint& operator=(const OutPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutPoint(OutPoint&& from) noexcept
    : OutPoint() {
    *this = ::std::move(from);
  }

  inline OutPoint& operator=(OutPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OutPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutPoint* internal_default_instance() {
    return reinterpret_cast<const OutPoint*>(
               &_OutPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(OutPoint* other);
  friend void swap(OutPoint& a, OutPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutPoint* New() const final {
    return CreateMaybeMessage<OutPoint>(NULL);
  }

  OutPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OutPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OutPoint& from);
  void MergeFrom(const OutPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes u256Hash = 1;
  void clear_u256hash();
  static const int kU256HashFieldNumber = 1;
  const ::std::string& u256hash() const;
  void set_u256hash(const ::std::string& value);
  #if LANG_CXX11
  void set_u256hash(::std::string&& value);
  #endif
  void set_u256hash(const char* value);
  void set_u256hash(const void* value, size_t size);
  ::std::string* mutable_u256hash();
  ::std::string* release_u256hash();
  void set_allocated_u256hash(::std::string* u256hash);

  // uint32 Index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Enze.OutPoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr u256hash_;
  ::google::protobuf::uint32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TxIn_2eproto;
};
// -------------------------------------------------------------------

class TxIn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Enze.TxIn) */ {
 public:
  TxIn();
  virtual ~TxIn();

  TxIn(const TxIn& from);

  inline TxIn& operator=(const TxIn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxIn(TxIn&& from) noexcept
    : TxIn() {
    *this = ::std::move(from);
  }

  inline TxIn& operator=(TxIn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxIn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxIn* internal_default_instance() {
    return reinterpret_cast<const TxIn*>(
               &_TxIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TxIn* other);
  friend void swap(TxIn& a, TxIn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxIn* New() const final {
    return CreateMaybeMessage<TxIn>(NULL);
  }

  TxIn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxIn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxIn& from);
  void MergeFrom(const TxIn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxIn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes cScriptSig = 2;
  void clear_cscriptsig();
  static const int kCScriptSigFieldNumber = 2;
  const ::std::string& cscriptsig() const;
  void set_cscriptsig(const ::std::string& value);
  #if LANG_CXX11
  void set_cscriptsig(::std::string&& value);
  #endif
  void set_cscriptsig(const char* value);
  void set_cscriptsig(const void* value, size_t size);
  ::std::string* mutable_cscriptsig();
  ::std::string* release_cscriptsig();
  void set_allocated_cscriptsig(::std::string* cscriptsig);

  // .Enze.OutPoint cPrevOut = 1;
  bool has_cprevout() const;
  void clear_cprevout();
  static const int kCPrevOutFieldNumber = 1;
  const ::Enze::OutPoint& cprevout() const;
  ::Enze::OutPoint* release_cprevout();
  ::Enze::OutPoint* mutable_cprevout();
  void set_allocated_cprevout(::Enze::OutPoint* cprevout);

  // uint32 uSequence = 3;
  void clear_usequence();
  static const int kUSequenceFieldNumber = 3;
  ::google::protobuf::uint32 usequence() const;
  void set_usequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Enze.TxIn)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cscriptsig_;
  ::Enze::OutPoint* cprevout_;
  ::google::protobuf::uint32 usequence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TxIn_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OutPoint

// bytes u256Hash = 1;
inline void OutPoint::clear_u256hash() {
  u256hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OutPoint::u256hash() const {
  // @@protoc_insertion_point(field_get:Enze.OutPoint.u256Hash)
  return u256hash_.GetNoArena();
}
inline void OutPoint::set_u256hash(const ::std::string& value) {
  
  u256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Enze.OutPoint.u256Hash)
}
#if LANG_CXX11
inline void OutPoint::set_u256hash(::std::string&& value) {
  
  u256hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Enze.OutPoint.u256Hash)
}
#endif
inline void OutPoint::set_u256hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  u256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Enze.OutPoint.u256Hash)
}
inline void OutPoint::set_u256hash(const void* value, size_t size) {
  
  u256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Enze.OutPoint.u256Hash)
}
inline ::std::string* OutPoint::mutable_u256hash() {
  
  // @@protoc_insertion_point(field_mutable:Enze.OutPoint.u256Hash)
  return u256hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OutPoint::release_u256hash() {
  // @@protoc_insertion_point(field_release:Enze.OutPoint.u256Hash)
  
  return u256hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OutPoint::set_allocated_u256hash(::std::string* u256hash) {
  if (u256hash != NULL) {
    
  } else {
    
  }
  u256hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), u256hash);
  // @@protoc_insertion_point(field_set_allocated:Enze.OutPoint.u256Hash)
}

// uint32 Index = 2;
inline void OutPoint::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 OutPoint::index() const {
  // @@protoc_insertion_point(field_get:Enze.OutPoint.Index)
  return index_;
}
inline void OutPoint::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Enze.OutPoint.Index)
}

// -------------------------------------------------------------------

// TxIn

// .Enze.OutPoint cPrevOut = 1;
inline bool TxIn::has_cprevout() const {
  return this != internal_default_instance() && cprevout_ != NULL;
}
inline void TxIn::clear_cprevout() {
  if (GetArenaNoVirtual() == NULL && cprevout_ != NULL) {
    delete cprevout_;
  }
  cprevout_ = NULL;
}
inline const ::Enze::OutPoint& TxIn::cprevout() const {
  const ::Enze::OutPoint* p = cprevout_;
  // @@protoc_insertion_point(field_get:Enze.TxIn.cPrevOut)
  return p != NULL ? *p : *reinterpret_cast<const ::Enze::OutPoint*>(
      &::Enze::_OutPoint_default_instance_);
}
inline ::Enze::OutPoint* TxIn::release_cprevout() {
  // @@protoc_insertion_point(field_release:Enze.TxIn.cPrevOut)
  
  ::Enze::OutPoint* temp = cprevout_;
  cprevout_ = NULL;
  return temp;
}
inline ::Enze::OutPoint* TxIn::mutable_cprevout() {
  
  if (cprevout_ == NULL) {
    auto* p = CreateMaybeMessage<::Enze::OutPoint>(GetArenaNoVirtual());
    cprevout_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Enze.TxIn.cPrevOut)
  return cprevout_;
}
inline void TxIn::set_allocated_cprevout(::Enze::OutPoint* cprevout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cprevout_;
  }
  if (cprevout) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cprevout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cprevout, submessage_arena);
    }
    
  } else {
    
  }
  cprevout_ = cprevout;
  // @@protoc_insertion_point(field_set_allocated:Enze.TxIn.cPrevOut)
}

// bytes cScriptSig = 2;
inline void TxIn::clear_cscriptsig() {
  cscriptsig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxIn::cscriptsig() const {
  // @@protoc_insertion_point(field_get:Enze.TxIn.cScriptSig)
  return cscriptsig_.GetNoArena();
}
inline void TxIn::set_cscriptsig(const ::std::string& value) {
  
  cscriptsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Enze.TxIn.cScriptSig)
}
#if LANG_CXX11
inline void TxIn::set_cscriptsig(::std::string&& value) {
  
  cscriptsig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Enze.TxIn.cScriptSig)
}
#endif
inline void TxIn::set_cscriptsig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cscriptsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Enze.TxIn.cScriptSig)
}
inline void TxIn::set_cscriptsig(const void* value, size_t size) {
  
  cscriptsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Enze.TxIn.cScriptSig)
}
inline ::std::string* TxIn::mutable_cscriptsig() {
  
  // @@protoc_insertion_point(field_mutable:Enze.TxIn.cScriptSig)
  return cscriptsig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxIn::release_cscriptsig() {
  // @@protoc_insertion_point(field_release:Enze.TxIn.cScriptSig)
  
  return cscriptsig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxIn::set_allocated_cscriptsig(::std::string* cscriptsig) {
  if (cscriptsig != NULL) {
    
  } else {
    
  }
  cscriptsig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cscriptsig);
  // @@protoc_insertion_point(field_set_allocated:Enze.TxIn.cScriptSig)
}

// uint32 uSequence = 3;
inline void TxIn::clear_usequence() {
  usequence_ = 0u;
}
inline ::google::protobuf::uint32 TxIn::usequence() const {
  // @@protoc_insertion_point(field_get:Enze.TxIn.uSequence)
  return usequence_;
}
inline void TxIn::set_usequence(::google::protobuf::uint32 value) {
  
  usequence_ = value;
  // @@protoc_insertion_point(field_set:Enze.TxIn.uSequence)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Enze

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_TxIn_2eproto
